#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 8
layout ( local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = WORKGROUP_SIZE ) in;

#define WORLD_SIZE 128
layout ( binding = 0 ) buffer InWorldDataBlock
{
    int mWorldData[ WORLD_SIZE * WORLD_SIZE * WORLD_SIZE ];
} inWorldData;

layout ( binding = 1 ) buffer OutWorldDataBlock
{
    int mWorldData[ WORLD_SIZE * WORLD_SIZE * WORLD_SIZE ];
} outWorldData;

layout(push_constant) uniform PushConstantsBlock
{
    float mTime;
} PushConstants;

float random(vec3 st) {
    return fract(sin(dot(st.xyz,
    vec3(12.9898,78.233,39.847)))*
    43758.5453123 + PushConstants.mTime );
}

void main()
{
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint z = gl_GlobalInvocationID.z;

    // If we're out of bounds, just return
    if( x >= WORLD_SIZE || y >= WORLD_SIZE || z >= WORLD_SIZE )
    {
        return;
    }

    uint index = x * WORLD_SIZE * WORLD_SIZE + y * WORLD_SIZE + z;

    uint liveNeighbors = 0;
    uint deadNeighbors = 0;
    int youngestNeighbor = 0;
    for( int x = -1; x <= 1; x++ )
    {
        for( int y = -1; y <= 1; y++ )
        {
            for( int z = -1; z <= 1; z++ )
            {
                if( x == 0 && y == 0 && z == 0 )
                {
                    continue;
                }

                ivec3 neighborpos = ivec3( x, y, z ) + ivec3( gl_GlobalInvocationID );
                if( neighborpos.x < 0 ) neighborpos.x += WORLD_SIZE;
                if( neighborpos.y < 0 ) neighborpos.y += WORLD_SIZE;
                if( neighborpos.z < 0 ) neighborpos.z += WORLD_SIZE;
                if( neighborpos.x >= WORLD_SIZE ) neighborpos.x -= WORLD_SIZE;
                if( neighborpos.y >= WORLD_SIZE ) neighborpos.y -= WORLD_SIZE;
                if( neighborpos.z >= WORLD_SIZE ) neighborpos.z -= WORLD_SIZE;

                uint neighborIndex = neighborpos.x * WORLD_SIZE * WORLD_SIZE + neighborpos.y * WORLD_SIZE + neighborpos.z;
                uint theNeighbor = inWorldData.mWorldData[ neighborIndex ];
                if( theNeighbor > 4 )
                {
                    youngestNeighbor = max( youngestNeighbor, int( theNeighbor ) );
                    liveNeighbors++;
                }
                else
                {
                    deadNeighbors++;
                }
            }
        }
    }

    int theCell = inWorldData.mWorldData[ index ];

    if( liveNeighbors == 1 && random( gl_GlobalInvocationID ) > .933f )
    {
        if( theCell == 0 )
        {
            outWorldData.mWorldData[ index ] = 5;
        }
        else
        {
            outWorldData.mWorldData[ index ] = 0;
        }
        return;
    }
    else
    {
        if( theCell > 0 ) outWorldData.mWorldData[ index ] = inWorldData.mWorldData[ index ] - 1;
    }
//    if( youngestNeighbor > 0 )
//    {
//        outWorldData.mWorldData[ index ] = youngestNeighbor - 1;
//        return;
//    }
//    if( theCell > 0 )
//    {
//        if( theCell > 0 ) outWorldData.mWorldData[ index ] = inWorldData.mWorldData[ index ] - 1;
//        return;
//    }

}
